## Dynamic Binding and Run Time Type ID
System decides at runtime how what the type is at runtime. 
Extremely valuable and can reduce complexity and give dynamic runtime characteristics

Keyword `virtual` is used to say determine binding at runtime

This allows for one line of code to call the right function based on `virtual tables` generated by the compiler.

Static binding is called compile time binding. The compiler uses the declared data type to determine which function to call.

Dynamic binding and using the keyword `virtual` tells the compiler to wait until runtime to bind an object.

Virtual belongs in the base class for most if not all methods that will be public to the derived classes and the derived classes all have a self similar interface.

## Implementation
### Upcasting

Upcasting - base class pointer can point to any kind of data within the hierarchy
In the client program, the base class pointer can be dynamic
This does not require any explicit type conversion syntax because every object within the hierarchy is a base object plus more. 

### Rules
These **must** be used, otherwise the binding will silently be static instead.
1. Uses a single inheritance hierarchy using public derivation. We need a hub for the virtual usage. This could be an abstract base class. 
2. There is a self similar interface across the hierarchy
	Dynamic binding requires functions have the same signature:
	1. have same return type
	2. same name
	3. same argument list 
3. Functions being bound are declared as virtual in the base class. They must be called through a base class pointer or reference.
4. Upcasting MUST be performed.  A base class reference or pointer refers to the desired derived object at runtime.


Upcasting allows us to create data structures where every node is pointing to different objects.

Dynamic binding allows the right function to be invoked at runtime. 

### Using the Base Class as a Hub
Can be an indirect base class or one that is a 'hub' for the rest of the hierarchy

`virtual` means we are expecting dynamic binding to take place and we should only place it in the base class unless we expect further derivation using RTTI.

The destructor MUST be dynamically bound in the base class.

The destructor NEEDS to be provided even if you don't have a specific purpose for it in the base class.

Without the virtual destructor in the hub, the correct destructor for all derived objects will not be invoked when dynamic binding is taking place.

```
//account.h
//base account class
class account{
	public:
		account(const char* = "none", float = 0);
		virtual void statement(); //virtual function
	private:
		char name[32];
		float balance;
};

//function definitions
//print 
void print_account(account *p) {//pointer
	p -> statement();
}

void print_account(account &r){
	r.statement();
}

//cycle through dynamically bound array of derived types
void print_statements(account *bank[], int n){
	for (int i = 0; i < n; ++i){
		bank[i] -> statement();
		cout << endl;
	}
}

//main
student smith("Joe Smith", 5000, "UT");

student *ps = &smith;
ps -> statement();

checking *pc =&smith;
pc -> statament();

account *pa = &smith;
pa -> statement();

print_account(&smith); //pass by ptr
print_account(smith); //pass by reference

savings i("Jim Jones", 500);
account a("Empty Account", 0);
student s("Kyle Smith", 5000, "UT");
checking c("Sue Smith", 1000);

account *bank[4];
bank[0] = &i;
bank[1] = &a;
bank[2] = &s;
bank[3] = &c;

print_statements(bank, 4);
```

### Upcasting/Downcasting
Upcasting is when the base class pointer or reference pointing to the base class or somewhere else in the derivation hierarchy.
We need to determine if we are pointing to as specific data type. 

Downcasting can be used to determine this and it requires the use of RTTI and an explicit type conversion.
It is needed when we have derived class methods that are not virtual in the base class.
Unlike upcasting, this is not required in order to perform dynamic binding, however when working with data structures, it often is.

```
//use new keyword so you can control the lifetime
Account *ptr{nullptr};
ptr = new Checking();
ptr -> function();
```


### RTTI
Determine at runtime what to allocate using `dynamic_cast`
```
Derived *ptr = dynamic_cast<Derived*>(a_base_class_pointer);

if (ptr) //if this is not NULL, allocate memory
	Data_member = new Derived(*ptr);
	
```
If copying from const references (object rather than ptr) need the const keyword and address of operator.
```
const Derived *ptr = dynamic_cast<const Derived*>(& const_base_reference);

OR

const Derived *ptr = dynamic_cast<const Derived*>(&const_derived_object);

THEN

if (ptr)
	Data_member = new Derived(*ptr);
```
##### Why use RTTI?
Say we have a non dynamically bound function in a derived class. 

The client program has "no idea" what data types being used, but it needs to find out in order to call a non-virtual derived class function.

If not using dynamic binding, we already know the data type. This is only used when we have been using `virtual` and dynamic binding.

RTTI provides the client with information about what pointers or references are referring to so they can call the correct named function.

##### static_cast for downcasting
Not a good idea, for example:

```
Hierarchy w/ dynamic binding (virtual in Account):

      Account
    _____|______
   |            |
Checking     Savings - float interest();
   |
Student

In the client:
//this will not compile
//we neede to have a savings pointer
Account *ptr = &savings_object;
f = ptr -> interst();

//so we try
//type conversion (make a copy)
//DOWNCASTING
Savings *s_ptr = static_cast<savings*>(ptr);

//compiler uses data type of the pointer to know where to look
//this compiles, but...
s_ptr -> interest();

...what if ptr was originally not a savings object.
//if the client originally had:
Account *ptr = &student_object;

//Student doesn't have the properties of a Savings object.
//this will compile, but there will be a runtime fault becuse
//Student doesn't have the memory of Savings
```
##### dynamic_cast is the solution
This is how we correctly type convert from a base class to the derived class.
At runtime, this will try to make the conversion, and return a 0 if the memory is not there (the above situation)
```
Revisiting the above example:
Account *ptr = &savings_object;
f = ptr -> interst(); //again, won't compile

//downcast w/ dynamic cast
savings *s_ptr = dynamic_cast<savings *>(ptr);

//check if the dynamic cast was successful before calling the non-virtual function
if (s_ptr)
	s_ptr -> interest();
	

//if we had started with
Account *ptr = &student_object;

//downcast to checking
checking *c_ptr = dynamic_cast<checking *>(ptr);

```
Downcasting takes a base class pointer and copies it into a derived class pointer type so we can call a derived class non-virtual member function.

All public derived class functions should be up in the base class as `virtual`

This is much better than being careful about casting - you have to be mindful of references and const

```
const Derived *ptr = dynamic_cast<const Derived *>(&const_derived_obj);
or 
const Derived *ptr = dynamic_cast<const Derived *>(&const_base_refernce);

//then
if (ptr) //if cast was successful, allocate mem for Derived
	Data_member = new Derived(*ptr);
```
##### RTTI, dynamic_cast, and constructors
```
//consider this code:
Account *ptr = new savings;

//we want:
Savings new_object(*ptr);

//so we use RTTI
Savings *s_ptr = dynamic_cast<Savings *>(ptr);
if (s_ptr)
	//do stuff
```

##### Alternatives
Use the `typeid` operator in the client in place of dynamic cast
```
#include <typeid>

if (typeid(*ps) == typeid(account))
//...etc for all damn possibilities! yikes.
```
### Abstract Base Class
2. If implementing the member functions in the base class doesn't make sense
	1. AND don't need a base class obj explicitly
	2. THEN an "Abstract Base Class" might work
3. Dynamic binding does not require the use of an ABC
4. It is accomplished by creating at least one "pure-virtual" func in the base
	```
	//prototype
	virtual void display() = 0;
	```
5. Added benefit - all derived classes must implement the pure virtual functions or else they too will become abstract

Acts as a specification for derived classes. 
Forces a derived class to implement, or they too become abstract
Cannot return or pass an ABC by reference or value

### Destructors
```
Account *ptr = new student;

//Account must have virtual keyword for statement(); or Accounts 
//statement will call, not student.statement();
ptr -> statement();

//Account must have virtual keyword for input();
//Same as statement() situation
ptr -> input(); 

//if ~Account() is not virtual, this will call ~Account() only! 
//This will cause a memory leak and ~student() will not be called!!
//if we use virtual at all, the base class destructor MUST be virtual
delete ptr;
```
This is why many IDE's just automatically add `virtual` to destructors.
This is a "safety feature" to prevent memory leaks, but we don't want to overuse virtual as it hints that dynamic binding is being implemented.

### Virtual Friend Functions
Dynamic binding can be used with overloaded operators. The operators must just be declared virtual in the base class.

Dynamic binding cannot be performed with binary arithmetic operators because they return by value.

Functions not overloaded as members will need to be virtual friend functions.

These need virtual helper member functions that the non member function can call.
These should be private or protected in the base class and all derived members.

### Examples
#### Static binding:
Compiler starts with the current object looking for the called function. If it doesn't find it, it goes up to the most base class. If it can't find the function, it will not compile. 
Static binding uses the data type of the object or pointer to determine which scope to find the function. In hierarchies, it will then search the parent's scope. 

```
//pointer
//no matter what is upcast through the arg
//the compiler will treat it as an account and call those functions
//STATIC BINDING
void print_account(account *p){
	p -> statement();
}

//reference
void print_account(account &r){
	r.statement();
}

int main(){
	student smith("Joe Smith", 5000, "UT");

	//upcasting examples
	//the compiler does not know anything about the student object
	//it just goes to the function of the data type of the pointer
	//this is static binding!
	student *ps = &smith;
	ps -> statement();
	
	checking *pc = &smith;
	pc -> statement();

	account *pa = &smith;
	pa -> statement();

	//upcast w/ function call
	//happens through the argument list
	print_account(&smith); //by pointer
	print account(smith);  //by reference 
}
```

#### Dynamic Binding (Run Time Binding):
**Overriding** a virtual function (we're taking a same name function in all derived classes, and the `virtual` keyword in the base class)
This tells the compiler to wait until runtime to decide which object to use

### Mixing Static and Dynamic Binding
If everything is mixed, it will be difficult to determine what to call when. Ugly code will result.
The application won't always be aware of what data type the upcasted pointer or reference is referring to.
If we have to micromanage this process, there was no point in using dynamic binding in the first place.

### Pointers and Dynamic Binding:
```
int p1; //int called p1
int *p2 //int pointer called p2
int **p3 //pointer to one or many int pointers, called p3
int p4[5]; //int array of 5(pointer to the first of 5 ints) called p4
int *p6(); //int returning function prototype
int (*p7)();  //pointer to any int returning function w/ no args
int *(*p8)(int); //pointer to an int pointer returning function that takes an int
```